Okay, this was a fun one. All we're handed is a pcap file and we're told to sort it out.

"We received a plea for help from a rather frustrated looking employee. He said he accidently 
ran malware on his computer, but when he tried to pay the "leet hacker" to get his files back 
they said the malware was "broken"... best IT could do was provide us a PCAP."

I pulled the pcap into Wireshark and had a look around. I found 11 traces, the first of which is the download
of a python script. The rest of the traces alternate between a quick "now sending" message and larger binary
files. Or at least binary-looking.

Let's take a look at that Python code and see what it says. It's a fairly straightforward set of functions
that takes a path, gets a list of all the files in a directory, XORs them with a random key, and then ships them
off to our attacker. Although our attacker has kindly commented out the part where they delete the files after
they're shipped, so that was nice of them.

There's exactly one comment in the file, so we should probably take note of that, eh?

> # DON'T FORGET TO CHANGE THIS TO THE REAL KEY!!!!

It looks like it used the same key to XOR "encrypt" the files, but it appears to use a random 32-byte key it 
generated at runtime. If we could figure out the key somehow, we could decrypt the files. Let's go back to the 
pcap and see what sorts of files we're dealing with. Maybe that will give us a clue.

A brief diversion into XOR: XORs are kinda cool. One cool property of XOR is called Involution, or 
self-inverse function. Which is a fancy way of saying if you have two inputs and you apply one of them twice,
you end up with the other one. So A XOR B XOR B = A. And A XOR B XOR A = B. We're gonna use this in a minute,
but I also just think it's kinda neat.

So now let's go back into Wireshark and download the files. Since the rans.py file was kind enough to send a
trace that included the filename, we can use Wireshark to download each file and we know what kind of file it
was. Now we have the following encrypted files: ecorp.png, resources.zip, WelcomeAboard.pdf, id_rsa and id_rsa.pub.

That's four different file types PDF, a .zip, a PNG, and two plain text files.

We know what the headers of the binary files look like (don't worry, I had to look these up):
ZIP file: Typically starts with bytes 50 4B 03 04.
PNG file: Starts with 89 50 4E 47 0D 0A 1A 0A.
PDF file: Starts with %PDF- (which in hex is 25 50 44 46 2D).

And we know the format of RSA public and private keys, since they're just text files.

If we can find the key and apply it to each of these files, the headers will be the same. ChatGPT was a bit of
a help here, because it analyzed the files for me and was able to at least come up with the first few bits
and handed me some code that I could use to read the files and XOR them, but I only fed it the binary files, so
it was only able to get the first few bytes of the key. And then I ran out of free chatGPT credits and I was on
my own because I'm cheap that way. This at least set me on the right path.

We know from reading the Python code that the key is 32-bytes long, but the headers of the binary files are
nowhere near that long. You know what's at least 32 bytes?

-----BEGIN OPENSSH PRIVATE KEY-----

Using that cool fact about XORs we learned earlier, we can now get the key to decrypt all the files! If we
XOR the first 32 bytes of the id_rsa file with the first 32 characters of the file declaration, we get the key!
Neat, right?

Before it crapped out on me, chatGPT was also kind enough to write me a list comprehension I could use decrypt
the files:

def xor(data,key):
    return bytes([data[i] ^ key[i % len(key)] for i in range(len(data))])

And again, because of that neat feature of XOR, we can pretty much lift the encrypt function wholesale with a
few minor modifications that I will leave to the reader in addition to needing to write the file out rather
than ship it over a socket.

Once we run our python decryptor on our three binary files, it gives us a roadmap to follow:
The PNG is there to make you feel like Mr. Robot
The PDF gives us the password to the zip file
The zip file, once inflated, contains the flag

Oh, and, uh, you might want to change your RSA keys, davey.

