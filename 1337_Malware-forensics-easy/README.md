# 1337 Malware
Category: Forensics<br>
Difficulty: Easy

Okay, this was a fun one. All we're handed is a pcap file and we're told to sort it out. Here are the instructions:

> We received a plea for help from a rather frustrated looking employee. He said he accidently 
ran malware on his computer, but when he tried to pay the "leet hacker" to get his files back 
they said the malware was "broken"... best IT could do was provide us a PCAP.

### Recon
I pulled the pcap into Wireshark and had a look around. I found 11 traces, the first of which is the download
of a python script from vvindowsupdate.com. Nice. Let's follow that and take a look. If you're unfamiliar with Wireshark,
select the line that says vvindowsupdate.com->right-click->Follow->TCP Stream. This will pop open a box that shows you
the python code. Let's save that to a file called `rans.py` so we can use it as we progress.

The rest of the traces alternate between a quick "now sending" message and larger binary files. Or at least 
binary-looking. We'll get to them next.

First let's take a look at that Python code. It's a fairly straightforward set of functions
that takes a path, gets a list of all the files in a directory, XORs them with a random key, and then ships them
off to our attacker. Although our attacker has kindly commented out the part where they delete the files after
they're shipped, so that was nice of them.

There's exactly one comment in the file, so we should probably take note of that, eh?

```
# DON'T FORGET TO CHANGE THIS TO THE REAL KEY!!!!
key = randbytes(32)
```
Looks like our attacker didn't follow the advice in the comment, and the code is generating a random 32-byte key at
runtime and using that key to encrypt all our files.

### Solve it!
So now let's go back into Wireshark and download the files. Since the rans.py file was kind enough to send a
trace that included the filename, we can use Wireshark to download each file and we know what kind of file it
was. Now we have the following encrypted files: 
* ecorp.png 
* resources.zip 
* WelcomeAboard.pdf 
* id_rsa
* id_rsa.pub

That's four different file types PDF, a .zip, a PNG, and two plain text files.

So here's where if I actually knew what I was doing, I could have jumped straight to the solution, but since this was
the first time I'd seen a challenge like this, I wasn't quite sure what to do next. This seemed like a good opportunity
to engage chatGPT. I asked chatGPT if, given a set of files that were XOR encrypted with the same 32-byte key, is it possible
to derive the key? I told it which types of files I had and it started helping. It proceeded to ignore the fact that I
had told it we had a 32-byte randomly generated key, and that two of them were an id_rsa keypair, and instead zeroed in
on the fact that one thing we did know was identifying header information of the various binary files.

It then helpfully offered to analyze the binary files and offered up what it claimed to be the key to decrypt the file.

The first file I fed it was the pdf, and it came back with:
> The recovered key from the encrypted PDF file is b'\x82\xc2SP\x8b'.

Then I fed it the png:
>The recovered key from the encrypted PNG file is b'\x82\xc2SP\x8b\xd5LG'.<br>
This key is different from the one recovered from the PDF file, suggesting a different key might have been used.

Okay. Sure, but sometimes chatGPT isn't as smart as we all hope it is. Because while it's suggesting that a different
key was used, simple visual inspection shows us that the first bytes are identical. Since the first bytes are identical,
it looks like we're at least on the right track in finding the key.

ChatGPT then told me I had asked too much of it and unless I wanted to give it money it was done answering my questions
for the day. Well, I had enough to go on to figure the rest of it out.

> [!NOTE]
> ### A brief diversion into XOR
> XORs are kinda cool. One cool property of XOR is called Involution, or
self-inverse function. Which is a fancy way of saying if you have two inputs and you apply one of them twice,
you end up with the other one. So A XOR B XOR B = A. And A XOR B XOR A = B. We're gonna use this in a minute,
but I also just think it's kinda neat.

So all chatGPT was doing as "analysis" was performing an XOR on the binary with the known headers and giving me the
resulting bytes back. Because if you XOR the encrypted file with the known header, you get at least those bytes of 
the key back.
The headers of the binary files look like:
* ZIP file: Typically starts with bytes 50 4B 03 04.
* PNG file: Starts with 89 50 4E 47 0D 0A 1A 0A.
* PDF file: Starts with %PDF- (which in hex is 25 50 44 46 2D).

We know from reading the Python code that the key is 32-bytes long, but the headers of the binary files are
nowhere near that long. You know what's at least 32 bytes?

`-----BEGIN OPENSSH PRIVATE KEY-----`

If I wanted to look like I actually knew what I was doing rather than learning how to solve the problem, I would have
just jumped to this point in the writeup immediately. But I had fun getting to the lightbulb moment, so you got to come
along for the ride.

Using that cool fact about XORs we learned earlier, we can now get the key to decrypt all the files! If we
XOR the first 32 bytes of the encrypted id_rsa file with the first 32 characters of the file declaration, we get the key!
Neat, right?

Before it crapped out on me, chatGPT was also kind enough to write me a list comprehension I could use decrypt
the files:
```
def xor(data,key):
    return bytes([data[i] ^ key[i % len(key)] for i in range(len(data))])
```
And again, because of that neat feature of XOR where encrypt and decrypt are the same thing, we can pretty much lift 
the encrypt function wholesale from `rans.py` with a few minor modifications that I will leave to the reader in 
addition to needing to write the file out rather than ship it over a socket.

Once we run our python decryptor on our three binary files, it gives us a roadmap to follow:
* The PNG is there to make you feel like Mr. Robot
* The PDF gives us the password to the zip file
* The zip file, once inflated, contains the flag

Oh, and, uh, you might want to change your RSA keys, davey.

